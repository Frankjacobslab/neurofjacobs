# Snakefile
# Tells which files to generate as specified by the rule 'all'

# Snakefile to quality check and estimate counts from RNA-Seq data on a reference genome (e.g. human genome hg19)
# Tells which files to generate as specified by the rule 'all'

import os
import subprocess

#########################
## Pipeline configuration
#########################

# configuration file
configfile: "config.yaml"

# Number of CPU (threads)
THREADS = config["threads"]

# Trimmomatic
ADAPTERFILE = config["trimmomatic"]["adapters"]
TRIMMOMATIC = config["trimmomatic"]["jarfile"]

##################
## Desired outputs
##################
FASTQC_REPORTS = expand("fastqc/trimmed/{sample}/{pair}/{sample}_{pair}_fastqc.html",sample=config["samples"],pair=["forward","reverse"])
STAR2PASS = "./star2pass/chrLength.txt"
MAPPING_LOGS = expand("results/mappinglogs/{sample}_Log.final.out",sample=config["samples"]) 
GENECOUNTS = "results/gene_counts.txt"
BIGWIG = expand("/zfs/scratch/mgalland_temp/neuro/bigwig/{sample}.{strand}.normalized.bw",sample=config["samples"],strand=["pos","neg"])
MASTER_FILES = ["results/Snakefile","results/config.yaml"]

rule all:
	input:
		STAR2PASS,
		MAPPING_LOGS,
		#GENECOUNTS,
		BIGWIG,
		MASTER_FILES 
	message: "RNA-Seq pipeline has been successfully run"

##############################################
## version documentation and copy master files
##############################################
rule copy_master_files:
    output:
        "results/Snakefile",
        "results/config.yaml"
    message:"copying master files (Snakefile and configuration files)"
    shell:
        "cp Snakefile results/;"
        "cp config.yaml results/"

#########
## bigWig
#########
rule convert_to_bigWig: 
    input:
        bedgraph = "/zfs/scratch/mgalland_temp/neuro/bigwig/{sample}.{strand}.normalized.sorted.bg",
        chroms = "chromSizes.tab"
    output:
        "results/bigwig/{sample}.{strand}.normalized.bw"
    message:"converting strand-specific bedGraph files for {wildcards.sample} and {wildcards.strand} strand to bigWig format"
    shell:
        "bedGraphToBigWig {input.bedgraph} {input.chroms} {output}"       

rule sort_bedgraph:
    input:
        "/zfs/scratch/mgalland_temp/neuro/bigwig/{sample}.{strand}.normalized.bg"
    output:
        "/zfs/scratch/mgalland_temp/neuro/bigwig/{sample}.{strand}.normalized.sorted.bg"
    message:"sorting {wildcards.sample} bedGraph file for strand {wildcards.strand}"
    shell:
        "bedSort {input} {output}"      

rule generate_chrom_sizes:
    input:
        genome2bit = config["refseqs"]["genome2bit"]
    output:
        "chromSizes.tab"
    message:"generating chromosome sizes"
    shell:"twoBitInfo {input} {output}"

#rule generate_scaled_bedgraph_strand:
 #   input:
  #      bam = "/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Aligned.sortedByCoord.out.bam",
   #     chroms = "chromSizes.tab"
   # output:
    #    plus = "/zfs/scratch/mgalland_temp/neuro/bigwig/{sample}.pos.normalized.bg",
     #   minus = "/zfs/scratch/mgalland_temp/neuro/bigwig/{sample}.neg.normalized.bg"
    #message:"generating scaled bedgraph file for {wildcards.sample}"
    #run:
     #   # count number of mapped reads (for bedgraph scaling) + keep number
      #  scaling_factor = subprocess.check_output("samtools view -F 0x4 " + input[0] + " | cut -f 1 | sort | uniq | wc -l",shell=True)
       # scaling_factor = scaling_factor.strip().decode()
        
	# create a bedgraph file for strand +
#        shell("bedtools genomecov -ibam {input.bam} -bg -scale " + str(scaling_factor) + " -g {input.chroms} -strand + > {output.plus}") 
#
        # create a bedgraph file for strand -
 #       shell("bedtools genomecov -ibam {input.bam} -bg -scale " + str(scaling_factor) + " -g {input.chroms} -strand - > {output.minus}")

rule generate_scaled_bedgraph_strand:
    input:
        bam = "/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Aligned.sortedByCoord.out.{strand}.bam",
        chroms = "chromSizes.tab",
        scaling = "scaling/{sample}.txt"
    output:
        "/zfs/scratch/mgalland_temp/neuro/bigwig/{sample}.{strand}.normalized.bg"
    message:"generating scaled bedgraph file for {wildcards.sample} and for {wildcards.strand} strand"
    shell:
        "scalingFactor=$(cat {input.scaling});"
        "bedtools genomecov -split -ibam {input.bam} -bg -scale $scalingFactor -g {input.chroms} > {output}"

rule separate_strands:
    input:
        "/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Aligned.sortedByCoord.out.bam"
    output:
        pos = "/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Aligned.sortedByCoord.out.pos.bam",
        neg = "/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Aligned.sortedByCoord.out.neg.bam"
    message:"filtering {wildcards.sample} BAM file (separating strands)"
    shell:
        "samtools view -1 -h -b -F 16 {input} > {output.pos};"
        "samtools view -1 -h -b -f 16 {input} > {output.neg}"

rule compute_number_mapped_reads:
    input:
         bam = "/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Aligned.sortedByCoord.out.bam"
    output:
        "scaling/{sample}.txt"
    message:"computing scaling factor for {wildcards.sample} (number of mapped reads)"   
    shell:"samtools view -F 0x4 {input} |cut -f 1|sort|uniq|wc -l > {output}"

################################################
## Count read alignments per feature (e.g. gene)
################################################
rule feature_counts:
    input:
        bams = expand("/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Aligned.sortedByCoord.out.bam",sample=config["samples"].keys()),
        annotation = config["annotations"]["refseqFromSubread"],
        genome = config["refseqs"]["genomefasta"]
    output:
        "results/gene_counts.txt"
    message:"summarizing read counts"
    shell:
        "featureCounts "
        "-t exon "			# specify how to count reads at feature level (e.g. exon)
        "-g gene_id " 			# specify how to count reads at meta-feature level (e.g. gene)
        "-T {THREADS} "
        "-G {input.genome} "		# ref genome sequence
        "-a {input.annotation} "	# annotation 
        "-F SAF "			# SAF or GTF (by default GTF)
        "-o {output} "
        "{input}"               	# can process more than one BAM file at once 
        

#############################
# Genome alignment using STAR
#############################
rule copy_mapping_logs:
    input:
        "/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Log.final.out"
    output:
        "results/mappinglogs/{sample}_Log.final.out" 
    message:"moving mapping log for {wildcards.sample} in {output}"
    shell:"mv {input} {output}"

rule map_to_genome_using_STAR:
    input:
        ref = "./star2pass/",
        forward = "/zfs/scratch/mgalland_temp/neuro/trimmed/{sample}_forward.fastq",
        reverse = "/zfs/scratch/mgalland_temp/neuro/trimmed/{sample}_reverse.fastq"
    output:
        temp("/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Aligned.sortedByCoord.out.bam"),
        temp("/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Aligned.sortedByCoord.out.bam.bai"),
        "/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_Log.final.out"
    message:"mapping the {wildcards.sample} reads to genome"
    params:
        prefix = "/zfs/scratch/mgalland_temp/neuro/mapped/{sample}_",
        maxmismatches = config["star"]["mismatches"],
        unmapped = config["star"]["unmapped"]	,
        multimappers = config["star"]["multimappers"],
        matchNminoverLread = config["star"]["matchminoverlengthread"] 	
    shell:
            "STAR --genomeDir {input.ref} "
            "--readFilesIn {input.forward} {input.reverse} "
            "--outFilterMultimapNmax {params.multimappers} "
            "--outFilterMismatchNmax {params.maxmismatches} "
            "--outFilterMatchNminOverLread {params.matchNminoverLread} "
            "--alignEndsType EndToEnd "
            "--runThreadN {THREADS} "
            "--outReadsUnmapped {params.unmapped} "
            "--outFileNamePrefix {params.prefix} "
            "--outSAMtype BAM SortedByCoordinate;"
            "samtools index {output[0]}"

#####################################################################
## STAR 2-pass: genome indexing + splice junctions database generation 
#####################################################################
rule star2pass_index:
    input:
        sjdb = "./star1pass/SJ.concatenated.out.tab",
        directory = "./star2pass/", 
        ref= config["refseqs"]["genomefasta"],
        gtf = config["annotations"]["gtf4genes"]
    output:
        STAR_2PASS = ["./star2pass/"+f for f in ["chrLength.txt","chrNameLength.txt","chrName.txt","chrStart.txt","Genome","genomeParameters.txt","SA","SAindex"]]
    message: "STAR 2nd pass: generating genome index"	
    shell:
        "STAR --runMode genomeGenerate "
        "--genomeDir {input.directory} "
        "--genomeFastaFiles {input.ref} "
        "--runThreadN {THREADS} "
        "--sjdbFileChrStartEnd {input.sjdb} "
        "--sjdbOverhang 99 "
        "--sjdbGTFfile {input.gtf};"
        "touch -h {output}"

rule create_star2pass_directory:
    output:"./star2pass/"
    message:"create directory for star2pass"
    shell:"mkdir -p ./star2pass/"

rule concatenate_sjdb:
    input:
        expand("./star1pass/{sample}_SJ.out.tab",sample=config["samples"].keys()),
    output:
        "./star1pass/SJ.concatenated.out.tab"
    message:"concatenating splice junctions from different samples "
    shell:"cat {input} >> {output}"

rule star1pass_align:
    input:
        forward = "/zfs/scratch/mgalland_temp/neuro/trimmed/{sample}_forward.fastq",
        reverse = "/zfs/scratch/mgalland_temp/neuro/trimmed/{sample}_reverse.fastq", 
        ref = "star_index/"
    output:
        "./star1pass/{sample}_SJ.out.tab",
        temp("./star1pass/{sample}_Aligned.out.sam")
    message:"STAR 1st pass: aligning {wildcards.sample} reads to generate splice junction files"
    params:"./star1pass/{sample}_"	
    shell: 		
        "STAR --runMode alignReads "
        "--genomeDir {input.ref} "
        "--readFilesIn {input.forward} {input.reverse} "
        "--outFileNamePrefix {params} "
        "--outFilterIntronMotifs RemoveNoncanonical "
        "--runThreadN {THREADS}"

 # sdjbOverhang specifies the length of the genomic sequence around the annotated junction to be used in constructing the splie junctions database. Ideally this length should be equal to ReadLength-1
rule star_genome_index:
    input:
        genome = config["refseqs"]["genomefasta"],
        gtf = config["annotations"]["gtf4genes"]
    output:
        "star_index/"
    message:"generation STAR genome index" 
    params:"star_index/"
    shell:
        "STAR --runMode genomeGenerate "
        "--genomeDir {params} "
        "--genomeFastaFiles {input.genome} "
        "--runThreadN {THREADS} "
        "--sjdbOverhang 99 "
        "-sjdbGTFfile {input.gtf}"

################################
## Fastqc reports after trimming
################################
rule fastqc_after_trimming:
    input:
        "/zfs/scratch/mgalland_temp/neuro/trimmed/{sample}_{pair}.fastq"
    output:
        "fastqc/trimmed/{sample}/{pair}/{sample}_{pair}_fastqc.html"
    message:"generating fastqc report for trimmed reverse {wildcards.sample} reads"
    params:
        "fastqc/trimmed/{sample}/{pair}/"
    shell:"fastqc --threads {THREADS} --outdir={params} {input}"
    
###########
## Trimming
###########
rule trimmomaticPaired:
    input:
        ADAPTERFILE,
        forward = lambda wildcards: config["fastqdir"] + config["samples"][wildcards.sample]["forward"],
        reverse = lambda wildcards: config["fastqdir"] + config["samples"][wildcards.sample]["reverse"]
    output:
        forward = "/zfs/scratch/mgalland_temp/neuro/trimmed/{sample}_forward.fastq",
        reverse = "/zfs/scratch/mgalland_temp/neuro/trimmed/{sample}_reverse.fastq",
        forwardUnpaired  = "/zfs/scratch/mgalland_temp/neuro/trimmed/{sample}_forward_unpaired.fastq",
        reverseUnpaired = "/zfs/scratch/mgalland_temp/neuro/trimmed/{sample}_reverse_unpaired.fastq",
    message:"Trimming {wildcards.sample} using Trimmomatic"
    log:"results/trimlogs/{sample}.trimlog"
    params :
        seedMisMatches =            str(config['trimmomatic']['seedMisMatches']),
        palindromeClipTreshold =    str(config['trimmomatic']['palindromeClipTreshold']),
        simpleClipThreshhold =      str(config['trimmomatic']['simpleClipThreshold']),
        LeadMinTrimQual =           str(config['trimmomatic']['LeadMinTrimQual']),
        TrailMinTrimQual =          str(config['trimmomatic']['TrailMinTrimQual']),
        windowSize =                str(config['trimmomatic']['windowSize']),
        avgMinQual =                str(config['trimmomatic']['avgMinQual']),
        minReadLen =                str(config['trimmomatic']['minReadLength']),
        phred = 		    str(config["trimmomatic"]["phred"])
    shell:
        "java -jar {TRIMMOMATIC} PE {params.phred} -threads {THREADS} "
        "{input.forward} {input.reverse} "
        "{output.forward} {output.forwardUnpaired} "
        "{output.reverse} {output.reverseUnpaired} "
        "ILLUMINACLIP:{ADAPTERFILE}:{params.seedMisMatches}:{params.palindromeClipTreshold}:{params.simpleClipThreshhold} "
        "LEADING:{params.LeadMinTrimQual} "
        "TRAILING:{params.TrailMinTrimQual} "
        "SLIDINGWINDOW:{params.windowSize}:{params.avgMinQual} "
        "MINLEN:{params.minReadLen} 2>{log}"


